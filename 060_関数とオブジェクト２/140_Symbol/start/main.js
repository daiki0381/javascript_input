/*
  ・プロパティの重複を避けるために、必ず一意の値を返す関数を「シンボル」という。
  ・ES5で独自に定義されたプロパティがES6になった際に追加されたプロパティと同名の場合、競合を起こして既存のES5のコードを壊してしまう恐れがあるので「シンボル」が導入された。
  ・「シンボル」を定義する時は、Symbol関数を呼び出す。
  ・Symbol関数の戻り値は必ず一意の値となる。
  ・Symbol関数の引数に値の名前を付けることができる。
  ・シンボルを使用した場合は、ブラケット記法になる。
*/

// 「シンボル」を定義する時は、Symbol関数を呼び出す。
//  Symbol関数の戻り値は必ず一意の値となる。
//  Symbol関数の引数に値の名前を付けることができる。
const s1 = Symbol('hello');
const s2 = Symbol('hello');

console.log(s1); // 「Symbol(hello)」が表示される。
//  値の名前が同じでも一意の値になるため「false」となる。
console.log(s1 === s2); // 「false」が表示される。

// 実例

//  プロパティ名が被っても、シンボルを使用すれば一意の値になるので安心。
//  シンボルを使用した場合は、ブラケット記法になる。
String.prototype[s1] = function () {
  //  インスタンス化した際に作成されたオブジェクトが「this」の参照先となる。
  return `Hello ${this}`;
};

//  プロパティ名が被っても、シンボルを使用すれば一意の値になるので安心。
//  シンボルを使用した場合は、ブラケット記法になる。
String.prototype[s2] = function () {
  //  インスタンス化した際に作成されたオブジェクトが「this」の参照先となる。
  return `Hello ${this}`;
};

const alice = 'Alice';

//  シンボルを使用した場合は、ブラケット記法になる。
console.log(alice[s1]()); // 「Hello Alice」が表示される。
//  シンボルを使用した場合は、ブラケット記法になる。
console.log(alice[s2]()); // 「Hello Alice」が表示される。
